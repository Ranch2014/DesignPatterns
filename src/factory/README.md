#工厂模式
工厂模式可以分为三种:简单工厂,工厂方法和抽象工厂.

本例的类结构示意图如下:  
![factory.png](https://github.com/Ranch2014/DesignPatterns/blob/master/images/factory.png)

##简单工厂
定义：类创建模式，用来创建其他类的实例，通过不同的特征返回不同类的实例，被返回类具有相同的父类.

优点:  
1. 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。  
2. 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。  
3. 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。  

缺点：  
1. 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。  
2. 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。  
3. 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。  
4. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。  

简单工厂模式的适用环境:  
1. 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂；  
2. 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 

##工厂方法
定义：定义一个用于创建对象的接口，使类得实例化延迟到子类，由子类来决定实例化哪一个类。

在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做。  
这个核心工厂则变为抽象工厂角色，仅负责给出具工厂子类必须实现的接口，而不接触哪一产品创建的细节。

这种抽象的结果，使这种工厂方法模式可以用来允许系统不修改具体工厂角色的情况下引进新产品，
这一特点无疑使得工厂模式具有超过简单工厂模式的优越性。

优点:  
1. 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。  
2. 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。  
3. 使用工厂方法模式的另一个优点是在系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。  

缺点:      
1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。  
2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。  

工厂方法模式的适用环境:    
1. 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。  
2. 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。  
3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 

##抽象工厂
定义：提供一个接口，创建一系列相关连的产品（产品族），而不必指定具体的类。  
通常，产品族是某个产品的组成部分，比如一个电脑的CPU,内测，硬盘等，一个开发团队的前端、后端、美工等

优点:    
1. 隔离了具体类的生成，使得用户不需要知道什么被创建了。  
2. 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。  

缺点:   
1. 添加新的产品对像时，难以扩展抽象工厂以便生产新种类的产品。  

抽象工厂模式的适用环境:  
1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。这对于所有形态的工厂模式都是重要的；  
2. 一个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品；  
3. 同属于同一个产品族的产品是在一起使用的，这一约束必须要在系统的设计中体现出来；  
4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。




简单工厂、工厂方法和抽象工厂三者的区别：

- 简单工厂：用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）
- 工厂方法：用来生产同一等级结构中的固定产品。（支持增加任意产品）
- 抽象工厂：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

PS: 就本例而言，若新增一个产品族，比如SeniorTeam，则需要增加SeniorClient(实现Client接口), SeniorServer(实现Server接口), SeniorTeamFactory(实现TeamFactory接口)。之前自己一直没理解“产品族”这个概念，导致没理解抽象工厂。



主要参考：

http://blog.csdn.net/lansuiyun/article/details/11872397

http://blog.csdn.net/superbeck/article/details/4446177

http://blog.csdn.net/wyxhd2008/article/details/5597975

